syntax = "proto3";
package memwallet;


// message MemoryWallet {
//     uint32 protoVersion = 1;         // the version of this wire format, for storage
   
//     Accounts accounts = 2;   // the accounts in this wallet
   
//     map<uint32, MemoryWalletBlock> blocks = 3; // map from block height to block data
// }



message Accounts {
    map<uint32, Account> accounts = 1; // map from account index to account data
    uint32 accountNonce = 2;         // the nonce for the next account
}

message Account {
    uint32 accountId = 1;         // the index of this account
    AccountKind kind = 2; // derived or imported

    optional bytes seed_fingerprint = 3;
    optional uint32 account_index = 5; // HD index to derive account from seed

    optional AccountPurpose purpose = 6; // spending or view-only

    string viewing_key = 7; // the viewing key for this account
    AccountBirthday birthday = 8; // the block height at which this account was created
    repeated Address addresses = 9; // account addresses
    map<uint32, EphemeralAddress> ephemeral_addresses = 10; // map from index to encoded unified address

}

enum AccountKind {
    Derived = 0;
    Imported = 1;
}

enum AccountPurpose {
    Spending = 0;
    ViewOnly = 1;
}

message AccountBirthday {
    ChainState prior_chain_state = 1; // the chain state at the block height before the account was created
    optional uint32 recover_until = 2; // the block height until which the account should stop being in recovery mode
}

message Address {
    bytes diversifierIndex = 1;
    string address = 2;
}

message EphemeralAddress {
    string address = 1;
    optional bytes used_in_tx = 2;
    optional bytes seen_in_tx = 3; 
}

message ChainState {
    uint32 blockHeight = 1; // the height of this block
    bytes block_hash = 2;
    bytes final_sapling_tree = 3;
    bytes final_orchard_tree = 4;
}




message WalletBlock {
    uint32 height = 1; // the height of this block
    bytes hash = 2; // the ID (hash) of this block, same as in block explorers
    uint32 block_time = 3; // Unix epoch time when the block was mined
    repeated bytes transactions = 4; // the txids of transactions in this block
    repeated Memo memos = 5; // map from note id to memo
    optional uint32 sapling_commitment_tree_size = 6; // the size of the Sapling note commitment tree as of the end of this block
    optional uint32 sapling_output_count = 7; // the number of Sapling outputs in this block
    optional uint32 orchard_commitment_tree_size = 8; // the size of the Orchard note commitment tree as of the end of this block
    optional uint32 orchard_action_count = 9; // the number of Orchard actions in this block
}

message NoteId {
    bytes tx_id = 1;
    ShieldedProtocol protocol = 2;
    uint32 output_index = 3;
}

enum ShieldedProtocol {
    sapling = 0;
    orchard = 1;
}

message Memo {
    NoteId note_id = 1;
    bytes memo = 2;
}
