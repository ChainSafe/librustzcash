syntax = "proto3";
package memwallet;

message MemoryWallet {
    Accounts accounts = 1;   // the accounts in this wallet
   
    map<uint32, WalletBlock> blocks = 2; // map from block height to block data
    repeated TransactionTableRecord tx_table = 3; // map from transaction id to transaction data
    
    repeated ReceivedNote received_note_table = 4; // the notes received by this wallet
    repeated ReceivedNoteSpendRecord received_note_spends = 5; // the notes spent by this wallet
    repeated NullifierRecord nullifiers = 6; // the nullifiers for notes spent by this wallet

    repeated SentNoteRecord sent_notes = 7;

    repeated TxLocatorRecord tx_locator = 8;
    repeated ScanQueueRecord scan_queue = 9;

    bytes sapling_tree = 10;
    repeated TreeEndHeightsRecord sapling_tree_shard_end_heights = 11;

    bytes orchard_tree = 12;
    repeated TreeEndHeightsRecord orchard_tree_shard_end_heights = 13;

    repeated TransparentReceivedOutputRecord transparent_received_outputs = 14;
    repeated TransparentReceivedOutputSpendRecord transparent_received_output_spends = 15;
    repeated TransparentSpendCacheRecord transparent_spend_map = 16;
    
    repeated TransactionDataRequest transaction_data_requests = 17;
}

message TxId {
    bytes hash = 1;
}

message TransactionTableRecord {
    TxId tx_id = 1;
    TransactionEntry tx_entry = 2;
}

// associates a note and a transaction where it was spent
message ReceivedNoteSpendRecord {
    NoteId note_id = 1;
    TxId tx_id = 2;
}

// records where a nullifier was spent by block height and tx index in that block
message NullifierRecord {
    Nullifier nullifier = 1;
    uint32 block_height = 2;
    uint32 tx_index = 3;
}

message SentNoteRecord {
    NoteId sent_note_id = 1;
    SentNote sent_note = 2;
}

// Maps a block height and transaction index to a transaction ID.
message TxLocatorRecord {
    uint32 block_height = 1;
    uint32 tx_index = 2;
    TxId tx_id = 3;
}

// Stores the block height corresponding to the last note commitment in a shard
// as defined by its level and index in the tree
message TreeEndHeightsRecord {
    uint32 level = 1;
    uint64 index = 2;
    uint32 block_height = 3;
}

message TransparentReceivedOutputRecord {
    OutPoint outpoint = 1;
    ReceivedTransparentOutput output = 2;
}

message TransparentReceivedOutputSpendRecord {
    OutPoint outpoint = 1;
    TxId tx_id = 2;
}

message TransparentSpendCacheRecord {
    TxId tx_id = 1;
    OutPoint outpoint = 2;
}

message Accounts {
    map<uint32, Account> accounts = 1; // map from account index to account data
    uint32 accountNonce = 2;         // the nonce for the next account
}

message Account {
    uint32 accountId = 1;         // the index of this account
    AccountKind kind = 2; // derived or imported

    optional bytes seed_fingerprint = 3;
    optional uint32 account_index = 5; // HD index to derive account from seed

    optional AccountPurpose purpose = 6; // spending or view-only

    string viewing_key = 7; // the viewing key for this account
    AccountBirthday birthday = 8; // the block height at which this account was created
    repeated Address addresses = 9; // account addresses
    map<uint32, EphemeralAddress> ephemeral_addresses = 10; // map from index to encoded unified address

}

enum AccountKind {
    Derived = 0;
    Imported = 1;
}

enum AccountPurpose {
    Spending = 0;
    ViewOnly = 1;
}

message AccountBirthday {
    ChainState prior_chain_state = 1; // the chain state at the block height before the account was created
    optional uint32 recover_until = 2; // the block height until which the account should stop being in recovery mode
}

message Address {
    bytes diversifierIndex = 1;
    string address = 2;
}

message EphemeralAddress {
    string address = 1;
    optional bytes used_in_tx = 2;
    optional bytes seen_in_tx = 3; 
}

message ChainState {
    uint32 blockHeight = 1; // the height of this block
    bytes block_hash = 2;
    bytes final_sapling_tree = 3;
    bytes final_orchard_tree = 4;
}




message WalletBlock {
    uint32 height = 1; // the height of this block
    bytes hash = 2; // the ID (hash) of this block, same as in block explorers
    uint32 block_time = 3; // Unix epoch time when the block was mined
    repeated bytes transactions = 4; // the txids of transactions in this block
    repeated Memo memos = 5; // map from note id to memo
    optional uint32 sapling_commitment_tree_size = 6; // the size of the Sapling note commitment tree as of the end of this block
    optional uint32 sapling_output_count = 7; // the number of Sapling outputs in this block
    optional uint32 orchard_commitment_tree_size = 8; // the size of the Orchard note commitment tree as of the end of this block
    optional uint32 orchard_action_count = 9; // the number of Orchard actions in this block
}

// A unique identifier for a shielded note or transparent utxo
message NoteId {
    TxId tx_id = 1;
    PoolType pool = 2;
    uint32 output_index = 3;
}

enum ShieldedProtocol {
    sapling = 0;
    orchard = 1;
}

message Memo {
    NoteId note_id = 1;
    bytes memo = 2;
}



message Note {
    ShieldedProtocol protocol = 1;
    bytes recipient = 2;
    uint64 value = 3;
    optional bytes rho = 4;
    RSeed rseed = 5;
}

message RSeed {
    optional RSeedType rseed_type = 1;
    bytes payload = 2;
}

enum RSeedType {
    BeforeZip212 = 0;
    AfterZip212 = 1;
}

message ReceivedNote {
    NoteId note_id = 1;
    TxId tx_id = 2;
    uint32 output_index = 3;
    uint32 account_id = 4;
    Note note = 5;
    optional Nullifier nullifier = 6;
    bool is_change = 7;
    bytes memo = 8;
    optional uint64 commitment_tree_position = 9;
    optional Scope recipient_key_scope = 10;
}

message Nullifier {
    ShieldedProtocol protocol = 1;
    bytes nullifier = 2;
}

message OutPoint {
    bytes hash = 1;
    uint32 n = 2;
}

enum Scope {
    Internal = 0;
    External = 1;
}

message SentNote {
    uint32 from_account_id = 1;
    Recipient to = 2;
    uint64 value = 3;
    bytes memo = 4;
}

message Recipient {
    RecipientType recipient_type = 1;

    optional string address = 2; // either the zcash address if external or transparent address if EphemeralTransparent
    optional PoolType pool_type = 3; // the shielded protocol if External
    optional uint32 account_id = 4; // the account id if EphemeralTransparent or InternalAccount
    optional OutPoint outpoint_metadata = 5; // the outpoint metadata if InternalAccount
    optional Note note = 6; // the note if InternalAccount
}

enum RecipientType {
    ExternalRecipient = 0;
    EphemeralTransparent = 1;
    InternalAccount = 2;
}

enum PoolType {
    Transparent = 0;
    ShieldedSapling = 1;
    ShieldedOrchard = 2;
}


message TransactionEntry {
    TransactionStatus tx_status = 1;
    optional uint32 block = 2;
    optional uint32 tx_index = 3;
    optional uint32 expiry_height = 4;
    optional bytes raw_tx = 5;
    optional uint64 fee = 6;
    optional uint32 target_height = 7;
    optional uint32 mined_height = 8;
}

enum TransactionStatus {
    TxidNotRecognized = 0;
    NotInMainChain = 1;
    Mined = 2;
}

message ReceivedTransparentOutput {
    bytes transaction_id = 1;
    uint32 account_id = 2;
    string address = 3;
    TxOut txout = 4;
    optional uint32 max_observed_unspent_height = 5;
}

message TxOut {
    uint64 value = 1;
    bytes script = 2;
}




message TransactionDataRequest {
    TransactionDataRequestType request_type = 1;
    // for the GetStatus and Enhancement variants
    optional TxId tx_id = 2;

    // for the SpendsFromAddress variant
    optional bytes address = 3;
    optional uint32 block_range_start = 4;
    optional uint32 block_range_end = 5;
}

enum TransactionDataRequestType {
    GetStatus = 0;
    Enhancement = 1;
    SpendsFromAddress = 2;
}

message ScanQueueRecord {
    uint32 start_height = 1;
    uint32 end_height = 2;
    ScanPriority priority = 3;
}


enum ScanPriority {
    /// Block ranges that are ignored have lowest priority.
    Ignored = 0;
    /// Block ranges that have already been scanned will not be re-scanned.
    Scanned = 1;
    /// Block ranges to be scanned to advance the fully-scanned height.
    Historic = 2;
    /// Block ranges adjacent to heights at which the user opened the wallet.
    OpenAdjacent = 3;
    /// Blocks that must be scanned to complete note commitment tree shards adjacent to found notes.
    FoundNote = 4;
    /// Blocks that must be scanned to complete the latest note commitment tree shard.
    ChainTip = 5;
    /// A previously scanned range that must be verified to check it is still in the
    /// main chain, has highest priority.
    Verify = 6;
}
