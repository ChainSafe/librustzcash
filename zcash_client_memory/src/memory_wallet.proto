syntax = "proto3";
package memwallet;


// message MemoryWallet {
//     uint32 protoVersion = 1;         // the version of this wire format, for storage
   
//     Accounts accounts = 2;   // the accounts in this wallet
   
//     map<uint32, MemoryWalletBlock> blocks = 3; // map from block height to block data
// }



message Accounts {
    map<uint32, Account> accounts = 1; // map from account index to account data
    uint32 accountNonce = 2;         // the nonce for the next account
}

message Account {
    uint32 accountId = 1;         // the index of this account
    AccountKind kind = 2; // derived or imported

    optional bytes seed_fingerprint = 3;
    optional uint32 account_index = 5; // HD index to derive account from seed

    optional AccountPurpose purpose = 6; // spending or view-only

    string viewing_key = 7; // the viewing key for this account
    AccountBirthday birthday = 8; // the block height at which this account was created
    repeated Address addresses = 9; // account addresses
    map<uint32, EphemeralAddress> ephemeral_addresses = 10; // map from index to encoded unified address

}

enum AccountKind {
    Derived = 0;
    Imported = 1;
}

enum AccountPurpose {
    Spending = 0;
    ViewOnly = 1;
}

message AccountBirthday {
    ChainState prior_chain_state = 1; // the chain state at the block height before the account was created
    optional uint32 recover_until = 2; // the block height until which the account should stop being in recovery mode
}

message Address {
    bytes diversifierIndex = 1;
    string address = 2;
}

message EphemeralAddress {
    string address = 1;
    optional bytes used_in_tx = 2;
    optional bytes seen_in_tx = 3; 
}

message ChainState {
    uint32 blockHeight = 1; // the height of this block
    bytes block_hash = 2;
    bytes final_sapling_tree = 3;
    bytes final_orchard_tree = 4;
}




message WalletBlock {
    uint32 height = 1; // the height of this block
    bytes hash = 2; // the ID (hash) of this block, same as in block explorers
    uint32 block_time = 3; // Unix epoch time when the block was mined
    repeated bytes transactions = 4; // the txids of transactions in this block
    repeated Memo memos = 5; // map from note id to memo
    optional uint32 sapling_commitment_tree_size = 6; // the size of the Sapling note commitment tree as of the end of this block
    optional uint32 sapling_output_count = 7; // the number of Sapling outputs in this block
    optional uint32 orchard_commitment_tree_size = 8; // the size of the Orchard note commitment tree as of the end of this block
    optional uint32 orchard_action_count = 9; // the number of Orchard actions in this block
}

message NoteId {
    bytes tx_id = 1;
    ShieldedProtocol protocol = 2;
    uint32 output_index = 3;
}

enum ShieldedProtocol {
    sapling = 0;
    orchard = 1;
}

message Memo {
    NoteId note_id = 1;
    bytes memo = 2;
}



message Note {
    ShieldedProtocol protocol = 1;
    bytes recipient = 2;
    uint64 value = 3;
    optional bytes rho = 4;
    RSeed rseed = 5;
}

message RSeed {
    optional RSeedType rseed_type = 1;
    bytes payload = 2;
}

enum RSeedType {
    BeforeZip212 = 0;
    AfterZip212 = 1;
}

message ReceivedNote {
    NoteId note_id = 1;
    bytes tx_id = 2;
    uint32 output_index = 3;
    uint32 account_id = 4;
    Note note = 5;
    optional Nullifier nullifier = 6;
    bool is_change = 7;
    bytes memo = 8;
    optional uint64 commitment_tree_position = 9;
    optional Scope recipient_key_scope = 10;
}

message Nullifier {
    ShieldedProtocol protocol = 1;
    bytes nullifier = 2;
}

message OutPoint {
    bytes hash = 1;
    uint32 n = 2;
}

enum Scope {
    Internal = 0;
    External = 1;
}

message SentNote {
    uint32 from_account_id = 1;
    Recipient to = 2;
    uint64 value = 3;
    bytes memo = 4;
}

message Recipient {
    RecipientType recipient_type = 1;

    optional string address = 2; // either the zcash address if external or transparent address if EphemeralTransparent
    optional PoolType pool_type = 3; // the shielded protocol if External
    optional uint32 account_id = 4; // the account id if EphemeralTransparent or InternalAccount
    optional OutPoint outpoint_metadata = 5; // the outpoint metadata if InternalAccount
    optional Note note = 6; // the note if InternalAccount
}

enum RecipientType {
    ExternalRecipient = 0;
    EphemeralTransparent = 1;
    InternalAccount = 2;
}

enum PoolType {
    Transparent = 0;
    ShieldedSapling = 1;
    ShieldedOrchard = 2;
}
